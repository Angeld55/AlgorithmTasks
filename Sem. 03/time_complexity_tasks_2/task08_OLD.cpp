#include <iostream>

// За тази функция направихме полагането  k = i + j и разгледахме T(k) = 2T(k-1) + 1.
// Това обаче НЕ е вярно за конкретната функция, защото е възможно за ЕДНАКВИ стойности на К да имаме РАЗЛИЧИ рекурсивни извиквания.

//Пример:
//  FuncHelp(3,10) -> извиква FuncHelp(2,10) и FuncHelp(3,9). Тук i+j=13  Т.е действително имаме Т(13) = 2T(12) + 1. 
//  FuncHelp(13,0) -> НЕ ИЗВИКВА нищо рекурсивно. И тук НЕ Е вярно, че  Т(13) = 2T(12) + 1.

//Тоест с нашето полагане ние НЕ ЗНАЕМ кога ще е дъното на рекурсията - може да дойде за всяка стойност на K (Ако i=k или j = k).

// Решението, което направихме в час работи за модифицирания пример (task8.cpp)

// Скица на правилното решение на задачата:
//Задачата се решава малко по-сложно. Игнорирайки мултипликативните константи (10 и 11) ще получим формулата за броят пътищя в grid-град от (0,0) до (i,j).
// Техният брой е  ( i + j  над  i ) = ( i + j  над  j ). Но ние искаме i = j = n. Т.е  ( 2n  над  n ), което по порядък е (4^n)/ sqrt(n).
// Сложността тогава е  (4^n)/ sqrt(n).

int funcHelp(int i,int j)
{
	if (i == 0)
		return 1;
    if(j == 0)
		return 0;
	
	return 10 * funcHelp(i-1, j) + 11 * funcHelp(i,j-1);
}

int task9(int n)
{
	return funcHelp(n,n);
}


int main()
{

	std::cout << task9(20);
}
